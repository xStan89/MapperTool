<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Gwyn Morgan Network</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Rubik:wght@400;700&display=swap');
    
    :root {
      --text-black: #020202;
      --near-black: #383838;
      --bg-white: #d3d3d3;
      --panel-grey: #C2C2C2;
      --main-yellow: #FFD241;
      --shadow-grey: #9E9E9E;
      --light-yellow: #FFEDB4;
      --shadow-yellow: #DEB555;
      --light-grey:  #d8d8d8;
      --highlight-white: #FFFFFF;
      --error-red: #dc2626;
      --story-blue: #3B82F6;
      --story-blue-hover: #60A5FA;
      --font-family: 'Rubik', Arial, Helvetica, sans-serif;
    }
    
    html,body { 
      width:100%;
      height: 100vh;
      max-height:1000px;  
      margin:0; 
      font-family: var(--font-family); 
      background:var(--bg-white); 
      align-items: center;
      justify-content: center;
    }
    html, body {overscroll-behavior: none;}

    #wrap { display:flex; width:100%; height:100%; overflow:hidden; }

    /* GRAPH AREA */
    #graph-area { position:relative; flex:1; background:var(--bg-white); }
    canvas { width:100%; height:100%; display:block; background:var(--bg-white); }

    /* LOGO */
    #logo {
      position: absolute;
      bottom: 6px;
      right: 22px;
      z-index: 10;
      opacity: 1;
      pointer-events: none;
    }
    
    #logo img {
      height: 55px;
      width: auto;
    }

    /* TOP CONTROLS - ZOOM */
    #top-controls {
      position: absolute;
      top: 12px;
      right: 12px;
      display: flex;
      gap: 12px;
      z-index: 10;
    }

    #zoom-controls {
      display: flex;
      gap: 8px;
    }
    
    .zoom-btn {
      padding: 6px 8px;
      border-radius: 20px;
      border: none;
      cursor: pointer;
      background: var(--panel-grey);
      color: var(--text-black);
      font-size: 18px;
      font-weight: bold;
      min-width: 35px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: var(--font-family);
    }
    
    .zoom-btn:hover {
      background: var(--light-yellow);
    }

    /* INFO PANEL (RIGHT) */
    #info-panel {
      width: 30vw;
      min-width: 20vw;  
      max-width: 30vw;
      height: 100vh;
      max-height: 1000px;
      background: var(--highlight-white);
      color: var(--text-black);
      padding: 12px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      border-left: 1px solid var(--highlight-white);
      font-size: 14px;
      /*height: 100vh;*/
      overflow: hidden;
      transition: width 0.3s ease, min-width 0.3s ease, max-width 0.3s ease, padding 0.3s ease;
      position: relative;
    }
    
    #controls { 
      display: flex; 
      gap: 8px; 
      align-items: center; 
      flex-shrink: 0; 
      margin-bottom: 8px;
    }
    #search-box { display: flex; width: 100%; gap: 6px; flex-wrap: wrap; }
    #search-input { 
      flex: 1; 
      min-width: 0;
      padding: 6px 8px; 
      border-radius: 4px; 
      border: 1px solid var(--shadow-grey); 
      background: rgba(255,255,255,0.5); 
      color: var(--text-black);
      font-family: var(--font-family); 
    }
    #search-btn, #clear-btn { 
      padding: 8px 8px; 
      border-radius: 4px; 
      border: none; 
      cursor: pointer; 
      background: var(--main-yellow); 
      color: var(--text-black);
      font-family: var(--font-family);
      font-weight: bold;
      flex-shrink: 0;
      white-space: nowrap;
    }
    
    #search-btn:hover, #clear-btn:hover {
      background: var(--light-yellow);
    }
    
    /* Hide search buttons in story mode */
    .story-mode-hide {
      display: none !important;
    }

    #suggestions { 
      background: rgba(255,255,255,0.5); 
      border: 1px solid var(--shadow-grey); 
      max-height: 160px; 
      overflow: auto; 
      display: none; 
      padding: 6px; 
      border-radius: 4px; 
    }
    .suggestion { 
      padding: 6px; 
      cursor: pointer; 
      border-bottom: 1px dashed var(--shadow-grey); 
    }
    .suggestion:hover { 
      background: var(--light-yellow); 
    }

    #node-info { 
      margin-top: 8px; 
      padding: 8px; 
      background: var(--highlight-white); 
      border-radius: 6px; 
      flex-shrink: 0;
    }
    #node-title { font-weight: 700; }
    .muted { color: var(--shadow-grey); font-weight: 700; }

    #node-links {
      margin-top: 8px;
      flex-shrink: 0;
    }

    #connections-box {
      margin-top: -6px;
      background: var(--highlight-white);
      border-radius: 6px;
      padding: 6px;
      overflow: auto;
      border: 1px solid var(--shadow-grey);
      flex: 1;
      min-height: 0;
    }
    .conn-item {
      padding: 6px;
      cursor: pointer;
      font-size: 14px;
      color: var(--text-black);
      border-bottom: 1px dashed var(--shadow-grey);
    }
    .conn-item:hover { 
      background: var(--light-yellow); 
    }

    #msg { margin-top: 6px; color: var(--error-red); font-size: 14px; min-height: 18px; }

    /* LOADING OVERLAY */
    #loading-overlay {
      position: fixed;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      gap: 10px;
      background: rgba(250,250,250,0.9);
      z-index: 99999;
      font-size: 16px;
      color: var(--text-black);
    }
    .spinner {
      width: 64px;
      height: 64px;
      border-radius: 50%;
      border: 8px solid var(--shadow-grey);
      border-left-color: var(--main-yellow);
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }


    /* STORY MODE BUTTONS */
    #story-btn {
      padding: 8px 8px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      background: var(--story-blue);
      color: white;
      font-family: var(--font-family);
      font-weight: bold;
      flex-shrink: 0;
      white-space: nowrap;
      margin-bottom: 8px;
      width: 100%;
      display: none;
      animation: glow 2s ease-in-out infinite;
    }

    #story-btn:hover {
      background: var(--story-blue-hover);
    }

    #story-nav-container {
      display: none;
      gap: 4px;
      margin-top: 14px;
      flex-shrink: 0;
    }

    #story-nav-container.active {
      display: flex;
    }

    .story-nav-btn {
      padding: 8px 6px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      background: var(--story-blue);
      color: white;
      font-family: var(--font-family);
      font-weight: bold;
      font-size: 12px;
      white-space: nowrap;
      flex: 1;
    }

    .story-nav-btn:hover:not(:disabled) {
      background: var(--story-blue-hover);
    }

    .story-nav-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    @keyframes glow {
      0%, 100% { box-shadow: 0 0 5px var(--story-blue); }
      50% { box-shadow: 0 0 20px var(--story-blue), 0 0 30px var(--story-blue-hover); }
    }

    /* ENTITY MODAL IN STORY MODE */
    #entity-modal {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--panel-grey);
      z-index: 1000;
      display: none;
      flex-direction: column;
      padding: 12px;
      box-sizing: border-box;
    }

    #entity-modal.active {
      display: flex;
    }

    #entity-modal-close {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 28px;
      height: 28px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      background: var(--error-red);
      color: white;
      font-family: var(--font-family);
      font-weight: bold;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1001;
    }

    #entity-modal-close:hover {
      background: #b91c1c;
    }

    #entity-modal-content {
      flex: 1;
      overflow: auto;
      margin-top: 8px;
    }

    /* VIEW CONTENT STYLES */
    #view-content {
      display: none;
    }

    #view-content.active {
      display: block;
    }

    .view-title {
      font-size: 28px;
      font-weight: 700;
      margin-bottom: 12px;
      color: var(--text-black);
    }

    .view-progress {
      font-size: 14px;
      font-weight: 700;
      color: var(--shadow-grey);
      margin-bottom: 12px;
    }

    .view-image {
      width: 100%;
      max-width: 100%;
      height: auto;
      border-radius: 6px;
      margin-bottom: 12px;
      object-fit: contain;
    }

    .view-text {
      font-size: 16px;
      line-height: 1.5;
      white-space: pre-wrap;
      word-wrap: break-word;
      max-height: 33vw;
      overflow-y: auto;
    }

    /* responsive
    @media (max-width: 900px) { 
      #info-panel { width: 260px; min-width: 260px; max-width: 260px; } 
    } */
  </style>
</head>
<body>
  <div id="wrap">
    <div id="graph-area">
      <canvas id="canvas"></canvas>
      
      <div id="logo">
        <img src="https://i.ibb.co/RXfZbS8/De-Smog-Logo-small.png" alt="Logo">
      </div>
      
      
      <div id="top-controls">
        <div id="zoom-controls">
          <button id="zoom-in" class="zoom-btn" title="Zoom In">+</button>
          <button id="zoom-out" class="zoom-btn" title="Zoom Out">−</button>
          <button id="zoom-reset" class="zoom-btn" title="Reset Zoom">↻</button>
        </div>
      </div>

      <div id="loading-overlay">
        <div class="spinner"></div>
        <div id="loading-text">Loading data...</div>
      </div>
    </div>

    <aside id="info-panel">
      <div id="controls">
        <div id="search-box">
          <input id="search-input" placeholder="Search..." />
          <button id="search-btn">Search</button>
          <button id="clear-btn">Clear</button>
        </div>
      </div>
      <button id="story-btn">Start Story</button>
      <div id="suggestions"></div>

      <div id="view-content">
        <div class="view-progress" id="view-progress"></div>
        <div class="view-title" id="view-title"></div>
        <img class="view-image" id="view-image" style="display: none;" />
        <div class="view-text" id="view-text"></div>
      </div>

      <div id="story-nav-container">
        <button id="story-prev-btn" class="story-nav-btn">◀ Back</button>
        <button id="story-next-btn" class="story-nav-btn">Next ▶</button>
        <button id="story-exit-btn" class="story-nav-btn">Exit Story</button>
      </div>

      <div id="node-info">
        <div id="node-title">Select a node or start story</div>
        <div id="node-meta" class="muted" style="margin-top:6px;"></div>
      </div>

      <div id="node-links"></div>

      <div id="connections-box"></div>

      <div id="msg"></div>

      <!-- Entity Modal for Story Mode -->
      <div id="entity-modal">
        <button id="entity-modal-close">✕</button>
        <div id="entity-modal-content">
          <div id="entity-modal-title"></div>
          <div id="entity-modal-connections"></div>
        </div>
      </div>
    </aside>
  </div>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
  <script>
  /************************************************************************
   * CONFIG
   ************************************************************************/
  const CONFIG = {
    colorPalette: d3.schemeTableau10,
    pointOpacity: 1.0,
    unconnectedOpacity: 0.15,
    linkOpacityNoSelection: 0.8,
    linkOpacitySelected: 0.8,
    labelFontSize: 17,
    labelBoxPadding: 4,
    labelOffsetY: 4,
    labelBoxOpacity: 0.6,
    gridSize: 25,
    dragDelayMs: 600,
    force: {
      linkDistance: 30,
      linkStrength: 0.8,
      chargeStrength: -300,
      collisionPadding: 10,
      velocityDecay: 0.1
    },
    showImages: true,
    maxSuggestions: 25,
    zoomMin: 0.2,
    zoomMax: 5.0,
    zoomStep: 0.2,
    // DATA FOLDER - Change this path to point to your data folder
    dataFolder: 'https://xstan89.github.io/NewMapper/'
  };

  const PADDING = 80;

  // Default Formatting Settings
  let formattingSettings = {
    nodeColor: '#000000',
    nodeHoverColor: '#FFD241',
    outlineColor: '#E3E3E3',
    outlineHoverColor: '#FFD241',
    outlineThickness: 4,
    outlineHoverThickness: 5,
    lineColor: '#000000',
    lineHoverColor: '#FFD241',
    lineThickness: 3,
    lineHoverThickness: 5,
    backgroundColor: '#E3E3E3',
    nodeSizeMode: 'connections',
    customNodeSize: 30,
    minNodeSize: 12,
    maxNodeSize: 80,
    sizeScale: 1.0
  };

  // Global state
  let nodes = [];
  let animationTime = 0;
  let animationScheduled = false;
  let links = [];
  let nodeById = new Map();
  let adjacency = new Map();
  let connectionSources = new Map();
  let connectionTexts = new Map();
  let nameIndex = [];
  let simulation = null;
  let selectedNode = null;
  let hoveredNode = null;
  let isDragging = false;
  let isDraggingNode = false;
  let draggedNode = null;
  let dragStartX = 0;
  let dragStartY = 0;
  let dragStartPanX = 0;
  let dragStartPanY = 0;
  let mouseDownNode = null;
  let mouseDownTime = 0;
  let dragDelayTimer = null;
  let didDrag = false;

  // Conditional Formatting State
  let conditionalFormats = [];

  // STORY MODE STATE
  let viewsData = [];
  let viewsById = new Map();
  let entityViewsMap = new Map();
  let entityHighlightsMap = new Map(); // entity name -> Set of view IDs where it should be highlighted
  let viewEntitiesCache = new Map();
  let isStoryMode = false;
  let currentViewIndex = 0;
  let sortedViewIds = [];
  let hasViewsColumn = false;

  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha: false });
  
  let zoomLevel = 1.0;
  let panX = 0;
  let panY = 0;

  const loadingOverlay = document.getElementById('loading-overlay');
  const loadingText = document.getElementById('loading-text');
  const searchInput = document.getElementById('search-input');
  const searchBtn = document.getElementById('search-btn');
  const clearBtn = document.getElementById('clear-btn');
  const suggestionsEl = d3.select('#suggestions');
  const nodeTitleEl = d3.select('#node-title');
  const nodeMetaEl = d3.select('#node-meta');
  const nodeLinkEl = d3.select('#node-links');
  const connectionsBox = document.getElementById('connections-box');
  const msgEl = d3.select('#msg');
  const zoomInBtn = document.getElementById('zoom-in');
  const zoomOutBtn = document.getElementById('zoom-out');
  const zoomResetBtn = document.getElementById('zoom-reset');

  // Story mode elements
  const storyBtn = document.getElementById('story-btn');
  const storyNavContainer = document.getElementById('story-nav-container');
  const storyPrevBtn = document.getElementById('story-prev-btn');
  const storyNextBtn = document.getElementById('story-next-btn');
  const storyExitBtn = document.getElementById('story-exit-btn');
  const viewContent = document.getElementById('view-content');
  const viewProgress = document.getElementById('view-progress');
  const viewTitle = document.getElementById('view-title');
  const viewImage = document.getElementById('view-image');
  const viewText = document.getElementById('view-text');
  const nodeInfo = document.getElementById('node-info');
  const entityModal = document.getElementById('entity-modal');
  const entityModalClose = document.getElementById('entity-modal-close');
  const entityModalTitle = d3.select('#entity-modal-title');
  const entityModalConnections = document.getElementById('entity-modal-connections');

  /************************************************************************
   * CANVAS SETUP
   ************************************************************************/
  function resizeCanvas() {
    const rect = canvas.getBoundingClientRect();
    const hiResScale = devicePixelRatio * 1.5;
    canvas.width  = Math.max(600, Math.floor(rect.width  * hiResScale));
    canvas.height = Math.max(400, Math.floor(rect.height * hiResScale));
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';
    ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
  }
  
  // Debounce timer for resize
  let resizeDebounceTimer = null;
  
  window.addEventListener('resize', () => { 
    resizeCanvas(); 
    
    // Immediate rescale for responsiveness
    if (nodes.length > 0 && originalDataBounds) {
      scaleNodesToFit();
    }
    
    if (simulation && simulation.force) { 
      const c = simulation.force('center'); 
      if (c) {
        c.x((canvas.width/(devicePixelRatio))/2);
        c.y((canvas.height/(devicePixelRatio))/2);
      }
    } 
    render();
    
    // Debounced final adjustment
    if (resizeDebounceTimer) clearTimeout(resizeDebounceTimer);
    resizeDebounceTimer = setTimeout(() => {
      if (nodes.length > 0 && originalDataBounds) {
        scaleNodesToFit();
        render();
      }
    }, 100);
  });
  
  resizeCanvas();

  /************************************************************************
   * NODE SIZING
   ************************************************************************/
  function updateNodeSizes() {
    if (nodes.length === 0) return;
    
    const connectionCounts = nodes.map(n => (adjacency.get(n.id) || new Set()).size);
    const maxConnections = Math.max(...connectionCounts, 1);
    const minConnections = Math.min(...connectionCounts, 0);
    
    nodes.forEach(n => {
      const conns = (adjacency.get(n.id) || new Set()).size;
      
      if (formattingSettings.nodeSizeMode === 'custom') {
        n.baseR = formattingSettings.customNodeSize;
      } else {
        const normalized = maxConnections > minConnections 
          ? (conns - minConnections) / (maxConnections - minConnections)
          : 0.5;
        
        n.baseR = formattingSettings.minNodeSize + normalized * (formattingSettings.maxNodeSize - formattingSettings.minNodeSize);
      }
      n.r = n.baseR;
    });
    
    applyNodeSizeScale();
  }
  
  function applyNodeSizeScale() {
    const scale = formattingSettings.sizeScale;
    nodes.forEach(n => {
      const format = getNodeFormat(n);
      if (format?.sizeEnabled && format?.nodeSize) {
        n.r = (format.nodeSize * scale) / 2;
      } else {
        n.r = (n.baseR || 15) * scale;
      }
    });
  }

  /************************************************************************
   * CONDITIONAL FORMATTING
   ************************************************************************/
  function invalidateFormatCache() {
    nodes.forEach(n => { n._cachedFormat = undefined; });
    links.forEach(l => { l._cachedFormat = undefined; });
  }

  function getNodeFormat(node) {
    if (node._cachedFormat !== undefined) return node._cachedFormat;
    
    for (const rule of conditionalFormats) {
      if (rule.type === 'entity') {
        if (rule.targets.includes(node.id)) {
          node._cachedFormat = rule;
          return rule;
        }
      } else if (rule.type === 'category') {
        const category = node.raw && node.raw['Category'];
        if (rule.targets.includes(category)) {
          node._cachedFormat = rule;
          return rule;
        }
      }
    }
    
    node._cachedFormat = null;
    return null;
  }

  function getLinkFormat(link) {
    if (link._cachedFormat) return link._cachedFormat;
    
    const sourceFormat = getNodeFormat(link.source);
    const targetFormat = getNodeFormat(link.target);
    
    if (sourceFormat && targetFormat) {
      const sourceIndex = conditionalFormats.indexOf(sourceFormat);
      const targetIndex = conditionalFormats.indexOf(targetFormat);
      link._cachedFormat = sourceIndex <= targetIndex ? sourceFormat : targetFormat;
    } else if (sourceFormat) {
      link._cachedFormat = sourceFormat;
    } else if (targetFormat) {
      link._cachedFormat = targetFormat;
    } else {
      link._cachedFormat = null;
    }
    
    return link._cachedFormat;
  }

  /************************************************************************
   * AUTO-LOAD DATA FROM FOLDER
   ************************************************************************/
  async function autoLoadData() {
    loadingOverlay.style.display = 'flex';
    loadingText.textContent = 'Loading data...';
    
    try {
      const entitiesUrl = CONFIG.dataFolder + 'Entities.csv';
      const connectionsUrl = CONFIG.dataFolder + 'Connections.csv';
      const formattingUrl = CONFIG.dataFolder + 'Formatting.csv';
      const viewsUrl = CONFIG.dataFolder + 'Views.csv';
      
      // Fetch entities and connections (required)
      const [entitiesResponse, connectionsResponse] = await Promise.all([
        fetch(entitiesUrl),
        fetch(connectionsUrl)
      ]);
      
      if (!entitiesResponse.ok || !connectionsResponse.ok) {
        throw new Error('Could not load required data files (Entities.csv and Connections.csv)');
      }
      
      const entitiesText = await entitiesResponse.text();
      const connectionsText = await connectionsResponse.text();
      
      const entitiesData = Papa.parse(entitiesText, { header: true, skipEmptyLines: true }).data;
      const connectionsData = Papa.parse(connectionsText, { header: true, skipEmptyLines: true }).data;
      
      // Try to load formatting (optional)
      try {
        const formattingResponse = await fetch(formattingUrl);
        if (formattingResponse.ok) {
          const formattingText = await formattingResponse.text();
          const formattingData = Papa.parse(formattingText, { header: true, skipEmptyLines: true }).data;
          loadFormattingData(formattingData);
        }
      } catch (e) {
        // Formatting file is optional, ignore errors
      }

      // Try to load views (optional)
      try {
        const viewsResponse = await fetch(viewsUrl);
        if (viewsResponse.ok) {
          const viewsText = await viewsResponse.text();
          const viewsDataParsed = Papa.parse(viewsText, { header: true, skipEmptyLines: true }).data;
          parseViewsData(viewsDataParsed);
        }
      } catch (e) {
        // Views file is optional, ignore errors
      }
      
      loadSession(entitiesData, connectionsData);
      
    } catch (err) {
      console.error('Failed to load data:', err);
      loadingText.textContent = 'Error: ' + err.message;
      setTimeout(() => {
        // Update story button visibility
    updateStoryButtonVisibility();

    loadingOverlay.style.display = 'none';
      }, 3000);
    }
  }

  function parseViewsData(data) {
    if (!data || data.length === 0) return;
    
    // Clean headers
    data.forEach(r => { 
      Object.keys(r).forEach(k => { 
        if (k !== k.trim()) { 
          r[k.trim()] = r[k]; 
          delete r[k]; 
        } 
      }); 
    });

    viewsData = data.map(r => ({
      id: String(r['View ID'] || '').trim(),
      title: String(r['View Title'] || '').trim(),
      text: String(r['View Text'] || '').trim(),
      image: String(r['View Image'] || '').trim()
    })).filter(v => v.id);

    // Build views by ID map
    viewsById.clear();
    viewsData.forEach(v => {
      viewsById.set(v.id, v);
    });

    // Sort view IDs numerically
    sortedViewIds = viewsData.map(v => v.id).sort((a, b) => {
      const numA = parseInt(a);
      const numB = parseInt(b);
      if (!isNaN(numA) && !isNaN(numB)) {
        return numA - numB;
      }
      return a.localeCompare(b);
    });
  }

  function loadFormattingData(data) {
    if (!data || data.length === 0) return;
    
    // Clean headers (remove extra spaces)
    data.forEach(r => { 
      Object.keys(r).forEach(k => { 
        if (k !== k.trim()) { 
          r[k.trim()] = r[k]; 
          delete r[k]; 
        } 
      }); 
    });
    
    conditionalFormats = [];
    
    data.forEach(row => {
      if (row.RuleType === 'Default' || !row.RuleType) {
        if (row.NodeColor) formattingSettings.nodeColor = row.NodeColor;
        if (row.NodeHoverColor) formattingSettings.nodeHoverColor = row.NodeHoverColor;
        if (row.LineColor) formattingSettings.lineColor = row.LineColor;
        if (row.LineHoverColor) formattingSettings.lineHoverColor = row.LineHoverColor;
        if (row.LineThickness) formattingSettings.lineThickness = parseFloat(row.LineThickness);
        if (row.LineHoverThickness) formattingSettings.lineHoverThickness = parseFloat(row.LineHoverThickness);
        if (row.OutlineColor) formattingSettings.outlineColor = row.OutlineColor;
        if (row.OutlineHoverColor) formattingSettings.outlineHoverColor = row.OutlineHoverColor;
        if (row.OutlineThickness) formattingSettings.outlineThickness = parseFloat(row.OutlineThickness);
        if (row.OutlineHoverThickness) formattingSettings.outlineHoverThickness = parseFloat(row.OutlineHoverThickness);
        if (row.BackgroundColor) {
          formattingSettings.backgroundColor = row.BackgroundColor;
          document.documentElement.style.setProperty('--bg-white', row.BackgroundColor);
        }
        if (row.SizeMode) formattingSettings.nodeSizeMode = row.SizeMode;
        if (row.CustomNodeSize) formattingSettings.customNodeSize = parseFloat(row.CustomNodeSize);
      } else if (row.RuleType === 'Entity' || row.RuleType === 'Category') {
        const targets = row.Targets ? row.Targets.split('|').map(t => t.trim()).filter(t => t) : [];
        
        const parsedNodeSize = row.NodeSize ? parseFloat(row.NodeSize) : null;
        const parsedNodeColor = row.NodeColor || null;
        const parsedOutlineColor = row.OutlineColor || null;
        const parsedOutlineThickness = row.OutlineThickness ? parseFloat(row.OutlineThickness) : null;
        const parsedLineColor = row.LineColor || null;
        const parsedLineThickness = row.LineThickness ? parseFloat(row.LineThickness) : null;
        
        conditionalFormats.push({
          type: row.RuleType.toLowerCase(),
          name: row.RuleName || 'Unnamed Rule',
          order: parseInt(row.Order) || conditionalFormats.length,
          targets: targets,
          nodeEnabled: parsedNodeColor ? true : (String(row.NodeEnabled).toLowerCase() === 'true'),
          nodeColor: parsedNodeColor,
          outlineEnabled: (parsedOutlineColor || parsedOutlineThickness) ? true : (String(row.OutlineEnabled).toLowerCase() === 'true'),
          outlineColor: parsedOutlineColor,
          outlineThickness: parsedOutlineThickness,
          sizeEnabled: parsedNodeSize ? true : (String(row.SizeEnabled).toLowerCase() === 'true'),
          nodeSize: parsedNodeSize,
          lineEnabled: (parsedLineColor || parsedLineThickness) ? true : (String(row.LineEnabled).toLowerCase() === 'true'),
          lineColor: parsedLineColor,
          lineThickness: parsedLineThickness
        });
      }
    });
    
    conditionalFormats.sort((a, b) => a.order - b.order);
    invalidateFormatCache();
  }

  /************************************************************************
   * LOAD SESSION
   ************************************************************************/
  function loadSession(entitiesData, connectionsData) {
    // Clean headers
    entitiesData.forEach(r => { 
      Object.keys(r).forEach(k => { 
        if (k !== k.trim()) { 
          r[k.trim()] = r[k]; 
          delete r[k]; 
        } 
      }); 
    });
    
    connectionsData.forEach(r => { 
      Object.keys(r).forEach(k => { 
        if (k !== k.trim()) { 
          r[k.trim()] = r[k]; 
          delete r[k]; 
        } 
      }); 
    });

    // Check if Entities.csv has Views column
    if (entitiesData.length > 0) {
      hasViewsColumn = 'Views' in entitiesData[0];
    }

    // Create nodes
    nodes = entitiesData.map((d, i) => createNodeFromData(d, i));
    nodeById = new Map(nodes.map(n => [n.id, n]));

    // Build entity views map if we have views
    if (hasViewsColumn) {
      buildEntityViewsMap(entitiesData);
      buildViewEntitiesCache();
    }

    // Create links
    processLinksData(connectionsData);

    // Build adjacency
    buildAdjacency();

    nameIndex = nodes.map(n => n.name);

    // Calculate node sizes
    updateNodeSizes();

    // Store original positions for rescaling on resize
    storeOriginalPositions();

    // Scale nodes to fit canvas (replaces centerNodesInCanvas)
    scaleNodesToFit();

    // Load images
    loadAllImages();

    // Start physics
    updatePhysics();

    // Update story button visibility
    updateStoryButtonVisibility();

    loadingOverlay.style.display = 'none';
  }

  // Store original data for rescaling on resize
  let originalNodePositions = new Map();
  let originalDataBounds = null;
  let currentScaleFactor = 1.0;
  
  function storeOriginalPositions() {
    originalNodePositions.clear();
    nodes.forEach(n => {
      const x = n.raw && !isNaN(parseFloat(n.raw['X'])) ? parseFloat(n.raw['X']) : n.x;
      const y = n.raw && !isNaN(parseFloat(n.raw['Y'])) ? parseFloat(n.raw['Y']) : n.y;
      originalNodePositions.set(n.id, { 
        x, 
        y, 
        isFixed: n.isFixed,
        baseR: n.baseR || formattingSettings.minNodeSize
      });
    });
    
    // Calculate and store original data bounds
    const positionedNodes = nodes.filter(n => n.isFixed || (n.raw && !isNaN(parseFloat(n.raw['X']))));
    if (positionedNodes.length >= 2) {
      let minX = Infinity, maxX = -Infinity;
      let minY = Infinity, maxY = -Infinity;
      
      positionedNodes.forEach(n => {
        const orig = originalNodePositions.get(n.id);
        minX = Math.min(minX, orig.x);
        maxX = Math.max(maxX, orig.x);
        minY = Math.min(minY, orig.y);
        maxY = Math.max(maxY, orig.y);
      });
      
      originalDataBounds = {
        minX, maxX, minY, maxY,
        width: maxX - minX,
        height: maxY - minY,
        centerX: (minX + maxX) / 2,
        centerY: (minY + maxY) / 2
      };
    }
  }

  function scaleNodesToFit() {
    if (nodes.length === 0) return;
    
    // Need original positions and bounds
    if (originalNodePositions.size === 0 || !originalDataBounds) {
      centerNodesInCanvas();
      return;
    }
    
    const dataWidth = originalDataBounds.width;
    const dataHeight = originalDataBounds.height;
    
    if (dataWidth === 0 || dataHeight === 0) {
      centerNodesInCanvas();
      return;
    }
    
    // Calculate available canvas space (with fixed margin for padding)
    const margin = PADDING + 40; // Fixed margin for largest expected scaled node
    
    const canvasW = (canvas.width / devicePixelRatio) - margin * 2;
    const canvasH = (canvas.height / devicePixelRatio) - margin * 2;
    
    // Calculate scale factor (preserving aspect ratio)
    const scaleX = canvasW / dataWidth;
    const scaleY = canvasH / dataHeight;
    currentScaleFactor = Math.min(scaleX, scaleY);
    
    // Clamp scale factor to reasonable bounds
    currentScaleFactor = Math.max(0.1, Math.min(currentScaleFactor, 3.0));
    
    // Calculate canvas center
    const canvasCenterX = (canvas.width / devicePixelRatio) / 2;
    const canvasCenterY = (canvas.height / devicePixelRatio) / 2;
    
    // Apply transformation to all nodes
    nodes.forEach(n => {
      const orig = originalNodePositions.get(n.id);
      if (!orig) return;
      
      // Scale position relative to data center, then translate to canvas center
      const newX = (orig.x - originalDataBounds.centerX) * currentScaleFactor + canvasCenterX;
      const newY = (orig.y - originalDataBounds.centerY) * currentScaleFactor + canvasCenterY;
      
      n.x = newX;
      n.y = newY;
      
      if (n.isFixed) {
        n.fx = newX;
        n.fy = newY;
      }
      
      if (n.unfixedX !== null) {
        n.unfixedX = newX;
        n.unfixedY = newY;
      }
      
      // Scale node radius - check for conditional format first
      const format = getNodeFormat(n);
      if (format?.sizeEnabled && format?.nodeSize) {
        n.r = (format.nodeSize * currentScaleFactor) / 2;
      } else {
        n.r = orig.baseR * currentScaleFactor;
      }
    });
    
    // Update collision force with new radii
    if (simulation && simulation.force('collision')) {
      simulation.force('collision').radius(d => d.r + CONFIG.force.collisionPadding);
    }
  }

  function centerNodesInCanvas() {
    if (nodes.length === 0) return;
    
    // Calculate bounding box of all nodes
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    
    nodes.forEach(n => {
      if (n.x < minX) minX = n.x;
      if (n.x > maxX) maxX = n.x;
      if (n.y < minY) minY = n.y;
      if (n.y > maxY) maxY = n.y;
    });
    
    // Calculate centroid of nodes
    const nodesCenterX = (minX + maxX) / 2;
    const nodesCenterY = (minY + maxY) / 2;
    
    // Calculate canvas center
    const canvasCenterX = (canvas.width / devicePixelRatio) / 2;
    const canvasCenterY = (canvas.height / devicePixelRatio) / 2;
    
    // Calculate offset to center nodes
    const offsetX = canvasCenterX - nodesCenterX;
    const offsetY = canvasCenterY - nodesCenterY;
    
    // Shift all nodes
    nodes.forEach(n => {
      n.x += offsetX;
      n.y += offsetY;
      if (n.fx !== null) n.fx += offsetX;
      if (n.fy !== null) n.fy += offsetY;
      if (n.unfixedX !== null) n.unfixedX += offsetX;
      if (n.unfixedY !== null) n.unfixedY += offsetY;
    });
  }

  function createNodeFromData(d, i) {
    const id = d['Entity Name'] ? String(d['Entity Name']).trim() : `__P_${i}`;
    
    const show = d['Show'] === undefined ? true : (String(d['Show']).toUpperCase() === 'TRUE' || d['Show'] === '1' || d['Show'] === true);
    const isFixed = String(d['Fixed']).toUpperCase() === 'TRUE' || d['Fixed'] === '1' || d['Fixed'] === true;
    const savedX = parseFloat(d['X']);
    const savedY = parseFloat(d['Y']);
    
    const x = !isNaN(savedX) && isFixed ? savedX : Math.random() * (canvas.width/(devicePixelRatio));
    const y = !isNaN(savedY) && isFixed ? savedY : Math.random() * (canvas.height/(devicePixelRatio));
    
    return {
      id, 
      name: id, 
      raw: d, 
      show,
      isFixed,
      image: d['Image'] ? d['Image'].trim() : null, 
      imageBitmap: null,
      x, 
      y,
      fx: isFixed ? x : null,
      fy: isFixed ? y : null,
      unfixedX: null,
      unfixedY: null,
      vx: 0, 
      vy: 0, 
      baseR: formattingSettings.minNodeSize,
      r: formattingSettings.minNodeSize
    };
  }

  function processLinksData(connectionsData) {
    const tmpLinks = connectionsData.map(r => ({
      sourceName: (r['A']||'').toString().trim(),
      targetName: (r['B']||'').toString().trim(),
      value: +((r['Link Size']||r['LinkSize']) || 1) || 1,
      source: (r['Source']||'').toString().trim(),
      note: (r['Note']||'').toString().trim(),
      text: (r['Text']||'').toString().trim()
    })).filter(l => l.sourceName && l.targetName);

    // Add missing nodes from links
    tmpLinks.forEach(l => {
      if (!nodeById.has(l.sourceName)) {
        const n = { 
          id: l.sourceName, 
          name: l.sourceName, 
          raw: {}, 
          show: true,
          isFixed: false,
          image: null, 
          imageBitmap: null, 
          x: Math.random() * (canvas.width/(devicePixelRatio)), 
          y: Math.random() * (canvas.height/(devicePixelRatio)), 
          fx: null,
          fy: null,
          unfixedX: null,
          unfixedY: null,
          vx: 0, 
          vy: 0, 
          baseR: formattingSettings.minNodeSize,
          r: formattingSettings.minNodeSize
        };
        nodes.push(n);
        nodeById.set(n.id, n);
      }
      if (!nodeById.has(l.targetName)) {
        const n = { 
          id: l.targetName, 
          name: l.targetName, 
          raw: {}, 
          show: true,
          isFixed: false,
          image: null, 
          imageBitmap: null, 
          x: Math.random() * (canvas.width/(devicePixelRatio)), 
          y: Math.random() * (canvas.height/(devicePixelRatio)), 
          fx: null,
          fy: null,
          unfixedX: null,
          unfixedY: null,
          vx: 0, 
          vy: 0, 
          baseR: formattingSettings.minNodeSize,
          r: formattingSettings.minNodeSize
        };
        nodes.push(n);
        nodeById.set(n.id, n);
      }
    });

    // Build links with references to node objects
    links = tmpLinks.map(l => ({
      source: nodeById.get(l.sourceName),
      target: nodeById.get(l.targetName),
      value: l.value,
      sourceUrl: l.source,
      note: l.note,
      text: l.text
    })).filter(l => l.source && l.target);
  }

  function buildEntityViewsMap(entitiesData) {
    entityViewsMap.clear();
    entityHighlightsMap.clear();
    
    entitiesData.forEach(row => {
      const entityName = String(row['Entity Name'] || '').trim();
      const viewsStr = String(row['Views'] || '').trim();
      const highlightStr = String(row['View Highlight'] || '').trim();
      
      if (entityName && viewsStr) {
        const viewIds = viewsStr.split(',').map(id => id.trim()).filter(id => id);
        entityViewsMap.set(entityName, viewIds);
      }
      
      if (entityName && highlightStr) {
        const highlightViewIds = highlightStr.split(',').map(id => id.trim()).filter(id => id);
        entityHighlightsMap.set(entityName, new Set(highlightViewIds));
      }
    });
  }

  function buildViewEntitiesCache() {
    viewEntitiesCache.clear();
    
    // Initialize cache for all views
    sortedViewIds.forEach(viewId => {
      viewEntitiesCache.set(viewId, []);
    });

    // Populate cache
    entityViewsMap.forEach((viewIds, entityId) => {
      viewIds.forEach(viewId => {
        // Only add if view exists in viewsById
        if (viewsById.has(viewId)) {
          const entityList = viewEntitiesCache.get(viewId);
          if (entityList) {
            entityList.push(entityId);
          }
        }
      });
    });
  }

  function updateStoryButtonVisibility() {
    const shouldShow = viewsData.length > 0 && hasViewsColumn;
    storyBtn.style.display = shouldShow ? 'block' : 'none';
  }

  function buildAdjacency() {
    adjacency.clear();
    connectionSources.clear();
    connectionTexts.clear();
    
    links.forEach(l => {
      const sId = l.source.id;
      const tId = l.target.id;
      
      if (!adjacency.has(sId)) adjacency.set(sId, new Set());
      if (!adjacency.has(tId)) adjacency.set(tId, new Set());
      adjacency.get(sId).add(tId);
      adjacency.get(tId).add(sId);
      
      // Track source URLs for connections
      if (l.sourceUrl) {
        if (!connectionSources.has(sId)) connectionSources.set(sId, new Map());
        if (!connectionSources.has(tId)) connectionSources.set(tId, new Map());
        connectionSources.get(sId).set(tId, l.sourceUrl);
        connectionSources.get(tId).set(sId, l.sourceUrl);
      }
      
      // Track text descriptions for connections
      if (l.text) {
        if (!connectionTexts.has(sId)) connectionTexts.set(sId, new Map());
        if (!connectionTexts.has(tId)) connectionTexts.set(tId, new Map());
        connectionTexts.get(sId).set(tId, l.text);
        connectionTexts.get(tId).set(sId, l.text);
      }
    });
  }

  /************************************************************************
   * STORY MODE
   ************************************************************************/
  function enterStoryMode() {
    if (sortedViewIds.length === 0) return;
    
    isStoryMode = true;
    currentViewIndex = 0;
    
    // Clear selection
    selectedNode = null;
    clearInfoPanel();
    
    // Hide normal UI elements
    storyBtn.style.display = 'none';
    nodeInfo.style.display = 'none';
    document.getElementById('node-links').style.display = 'none';
    connectionsBox.style.display = 'none';
    
    // Hide search controls and clear button in story mode
    document.getElementById('controls').classList.add('story-mode-hide');
    clearBtn.classList.add('story-mode-hide');
    
    // Show story UI elements
    storyNavContainer.classList.add('active');
    viewContent.classList.add('active');
    
    // Display current view
    updateStoryModeUI();
    
    // Animate pan & zoom to first view's nodes
    animateToViewNodes();
  }

  function exitStoryMode() {
    isStoryMode = false;
    
    // Clear selection
    selectedNode = null;
    hideEntityModal();
    
    // Reset zoom and pan
    zoomLevel = 1.0;
    panX = 0;
    panY = 0;
    
    // Show normal UI elements
    updateStoryButtonVisibility();
    nodeInfo.style.display = 'block';
    document.getElementById('node-links').style.display = 'block';
    connectionsBox.style.display = 'block';
    
    // Show search controls and clear button when exiting story mode
    document.getElementById('controls').classList.remove('story-mode-hide');
    clearBtn.classList.remove('story-mode-hide');
    
    // Hide story UI elements
    storyNavContainer.classList.remove('active');
    viewContent.classList.remove('active');
    
    // Clear info panel
    clearInfoPanel();
    render();
  }

  function navigateView(direction) {
    if (direction === 'prev' && currentViewIndex > 0) {
      currentViewIndex--;
    } else if (direction === 'next' && currentViewIndex < sortedViewIds.length - 1) {
      currentViewIndex++;
    }
    
    // Clear selection and hide modal when navigating
    selectedNode = null;
    hideEntityModal();
    
    updateStoryModeUI();
    
    // Animate pan & zoom to focus on current view nodes
    animateToViewNodes();
  }
  
  function animateToViewNodes() {
    const viewId = sortedViewIds[currentViewIndex];
    const viewEntities = new Set(viewEntitiesCache.get(viewId) || []);
    
    // Filter nodes in current view
    const viewNodes = nodes.filter(n => viewEntities.has(n.id));
    
    if (viewNodes.length === 0) {
      render();
      return;
    }
    
    // Calculate bounding box of view nodes including their radii
    let minX = Infinity;
    let maxX = -Infinity;
    let minY = Infinity;
    let maxY = -Infinity;
    
    viewNodes.forEach(n => {
      const radius = n.r || 15; // Use actual node radius
      minX = Math.min(minX, n.x - radius);
      maxX = Math.max(maxX, n.x + radius);
      minY = Math.min(minY, n.y - radius);
      maxY = Math.max(maxY, n.y + radius);
    });
    
    const width = maxX - minX;
    const height = maxY - minY;
    const dataCenterX = (minX + maxX) / 2;
    const dataCenterY = (minY + maxY) / 2;
    
    // Calculate target zoom to fit all nodes with padding
    const canvasWidth = canvas.width / devicePixelRatio;
    const canvasHeight = canvas.height / devicePixelRatio;
    const canvasCenterX = canvasWidth / 2;
    const canvasCenterY = canvasHeight / 2;
    const padding = 150; // padding in pixels
    
    const targetZoomX = width > 0 ? (canvasWidth - padding * 2) / width : 1.5;
    const targetZoomY = height > 0 ? (canvasHeight - padding * 2) / height : 1.5;
    let targetZoom = Math.min(targetZoomX, targetZoomY);
    
    // Clamp zoom to configured limits
    targetZoom = Math.max(CONFIG.zoomMin, Math.min(CONFIG.zoomMax, targetZoom));
    
    // Calculate target pan to center the nodes
    // Based on the transform: screen = (data - canvasCenter) * zoom + pan + canvasCenter
    // To center data at canvasCenter: pan = -(data - canvasCenter) * zoom
    const targetPanX = -(dataCenterX - canvasCenterX) * targetZoom;
    const targetPanY = -(dataCenterY - canvasCenterY) * targetZoom;
    
    // Store starting values
    const startZoom = zoomLevel;
    const startPanX = panX;
    const startPanY = panY;
    
    // Animation parameters
    const duration = 600; // milliseconds
    const startTime = Date.now();
    
    function animate() {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / duration, 1);
      
      // Ease-in-out function for smooth animation
      const eased = progress < 0.5 
        ? 2 * progress * progress 
        : 1 - Math.pow(-2 * progress + 2, 2) / 2;
      
      // Interpolate zoom and pan
      zoomLevel = startZoom + (targetZoom - startZoom) * eased;
      panX = startPanX + (targetPanX - startPanX) * eased;
      panY = startPanY + (targetPanY - startPanY) * eased;
      
      render();
      
      if (progress < 1) {
        requestAnimationFrame(animate);
      }
    }
    
    animate();
  }

  function updateStoryModeUI() {
    const viewId = sortedViewIds[currentViewIndex];
    const view = viewsById.get(viewId);
    
    if (!view) return;
    
    // Update progress
    viewProgress.textContent = `Page ${currentViewIndex + 1} of ${sortedViewIds.length}`;
    
    // Update title
    viewTitle.textContent = view.title;
    
    // Update image
    if (view.image) {
      viewImage.src = view.image;
      viewImage.style.display = 'block';
    } else {
      viewImage.style.display = 'none';
    }
    
    // Update text
    viewText.textContent = view.text;
    
    // Update navigation buttons
    storyPrevBtn.disabled = currentViewIndex === 0;
    storyNextBtn.disabled = currentViewIndex === sortedViewIds.length - 1;
  }

  function showEntityModal(node) {
    entityModal.classList.add('active');
    populateEntityModal(node);
  }

  function hideEntityModal() {
    entityModal.classList.remove('active');
    selectedNode = null;
  }

  function populateEntityModal(d) {
    const desc = (d.raw && (d.raw['Description'] || '')) || '';
    const category = (d.raw && (d.raw['Category'] || '')) || '';

    const rawLink = (d.raw && (d.raw['Link'] || d.raw['Link '])) || '';
    const safe = normalizeUrl(rawLink);
    const rawMoreInfo = (d.raw && (d.raw['DeSmog Profile'] || d.raw['DeSmog Profile'])) || '';
    const safeMoreInfo = normalizeUrl(rawMoreInfo);

    let links = [];
    if (safe) links.push(`<a href="${safe}" target="_blank" rel="noopener">More Info</a>`);
    if (safeMoreInfo) links.push(`<a href="${safeMoreInfo}" target="_blank" rel="noopener">DeSmog Profile</a>`);
    const linksHTML = links.length > 0 ? links.join(' | ') : '';

    entityModalTitle.html(`
      <div style="display:flex; align-items:center; gap:8px; font-size:24px; font-weight:700;">
        <span>${d.name}</span>
        ${d.image ? `<img src="${d.image}" style="width:40px; height:40px; object-fit:cover; border-radius:50%;">` : ''}
      </div>
      ${category ? `<div style="font-size: 16px; font-weight: bold; margin-top: 6px;">${category.replace(/\n/g, '<br>')}</div>` : ''}
      <br>
      ${desc ? `<div style="font-size: 14px; font-weight: normal; max-height: 350px; overflow-y: auto; margin-top: 6px;">${desc.replace(/\n/g, '<br>')}</div>` : ''}
      ${linksHTML ? `<div style="margin-top: 8px;">${linksHTML}</div>` : ''}
      <div style="font-size: 14px; font-weight: bold; margin-top: 6px;">
        <br>
        <br>Connections: 
      </div>
    `);

    // Get current view's entities for filtering connections
    const currentViewId = sortedViewIds[currentViewIndex];
    const currentViewEntities = new Set(viewEntitiesCache.get(currentViewId) || []);

    const conns = Array.from(adjacency.get(d.id) || []).slice();
    
    // Filter connections to only show those in current view
    const filteredConns = conns.filter(name => currentViewEntities.has(name));
    
    filteredConns.sort((a,b) => a.localeCompare(b, undefined, {sensitivity:'base'}));
    entityModalConnections.innerHTML = '';
    
    if (filteredConns.length === 0) {
      entityModalConnections.innerHTML = '<div class="muted" style="margin-top: 8px;">No connections in this view</div>';
      return;
    }
    
    const connBox = document.createElement('div');
    connBox.style.marginTop = '8px';
    connBox.style.background = 'var(--light-grey)';
    connBox.style.borderRadius = '6px';
    connBox.style.padding = '6px';
    connBox.style.border = '1px solid var(--shadow-grey)';
    connBox.style.maxHeight = '300px';
    connBox.style.overflow = 'auto';
    
    const frag = document.createDocumentFragment();
    const nodeSourceMap = connectionSources.get(d.id);
    const nodeTextsMap = connectionTexts.get(d.id);
    
    filteredConns.forEach(name => {
      const item = document.createElement('div');
      item.className = 'conn-item';
      item.style.display = 'flex';
      item.style.alignItems = 'center';
      item.style.justifyContent = 'space-between';
      item.style.gap = '8px';
      
      const nameSpan = document.createElement('span');
      // Display the text description if available, otherwise fall back to node name
      const textDesc = nodeTextsMap ? nodeTextsMap.get(name) : null;
      nameSpan.textContent = textDesc || name;
      nameSpan.style.flex = '1';
      nameSpan.style.cursor = 'pointer';
      nameSpan.addEventListener('click', () => {
        const targetNode = nodeById.get(name);
        if (targetNode) {
          selectedNode = targetNode;
          populateEntityModal(targetNode);
          render();
        }
      });
      item.appendChild(nameSpan);
      
      const sourceUrl = nodeSourceMap ? nodeSourceMap.get(name) : null;
      if (sourceUrl) {
        const sourceIcon = document.createElement('a');
        sourceIcon.href = normalizeUrl(sourceUrl) || '#';
        sourceIcon.target = '_blank';
        sourceIcon.rel = 'noopener';
        sourceIcon.innerHTML = '🔗';
        sourceIcon.style.fontSize = '16px';
        sourceIcon.style.textDecoration = 'none';
        sourceIcon.style.cursor = 'pointer';
        sourceIcon.style.flexShrink = '0';
        sourceIcon.title = 'View source';
        sourceIcon.addEventListener('click', (e) => {
          e.stopPropagation();
        });
        item.appendChild(sourceIcon);
      }
      
      frag.appendChild(item);
    });
    
    connBox.appendChild(frag);
    entityModalConnections.appendChild(connBox);
  }

  /************************************************************************
   * IMAGE LOADING
   ************************************************************************/
  function loadAllImages() {
    const imgNodes = nodes.filter(n => n.image && CONFIG.showImages);
    Promise.allSettled(imgNodes.map(n => loadImage(n))).then(() => render());
  }

  function loadImage(node) {
    return new Promise(async resolve => {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000);
        const resp = await fetch(node.image, { mode: 'cors', signal: controller.signal }).catch(()=>null);
        clearTimeout(timeoutId);
        if (!resp || !resp.ok) throw new Error('fetch failed');
        const blob = await resp.blob();
        if (typeof createImageBitmap === 'function') {
          const bmp = await createImageBitmap(blob, { resizeQuality: 'high' });
          node.imageBitmap = bmp;
          resolve();
        } else {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => { node.imageBitmap = img; resolve(); };
          img.onerror = () => { node.imageBitmap = null; resolve(); };
          img.src = URL.createObjectURL(blob);
        }
      } catch (err) {
        // Try direct image load as fallback
        try {
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.onload = () => { node.imageBitmap = img; resolve(); };
          img.onerror = () => { node.imageBitmap = null; resolve(); };
          img.src = node.image;
        } catch (e) {
          node.imageBitmap = null;
          resolve();
        }
      }
    });
  }

  /************************************************************************
   * PHYSICS SIMULATION
   ************************************************************************/
  function updatePhysics() {
    if (simulation) simulation.stop();
    
    const visibleNodes = nodes.filter(n => n.show);
    const visibleLinks = links.filter(l => l.source.show && l.target.show);
    
    if (visibleNodes.length === 0) {
      render();
      return;
    }
    
    simulation = d3.forceSimulation(visibleNodes)
      .force('link', d3.forceLink(visibleLinks)
        .id(d => d.id)
        .distance(d => Math.max(20, CONFIG.force.linkDistance / Math.sqrt(Math.max(0.5, d.value))))
        .strength(CONFIG.force.linkStrength))
      .force('charge', d3.forceManyBody().strength(CONFIG.force.chargeStrength))
      .force('center', d3.forceCenter(
        (canvas.width/(devicePixelRatio))/2, 
        (canvas.height/(devicePixelRatio))/2
      ))
      .force('collision', d3.forceCollide().radius(d => d.r + CONFIG.force.collisionPadding))
      .velocityDecay(CONFIG.force.velocityDecay)
      .on('tick', () => {
        visibleNodes.forEach(n => {
          n.x = Math.max(n.r + PADDING, Math.min((canvas.width/(devicePixelRatio)) - n.r - PADDING, n.x));
          n.y = Math.max(n.r + PADDING, Math.min((canvas.height/(devicePixelRatio)) - n.r - PADDING, n.y));
          
          // Save unfixed positions
          if (!n.isFixed) {
            n.unfixedX = n.x;
            n.unfixedY = n.y;
          }
        });
        render();
      });
    
    simulation.alpha(0.3).restart();
  }
  
  let physicsRestartTimer = null;
  function schedulePhysicsRestart() {
    if (physicsRestartTimer) clearTimeout(physicsRestartTimer);
    physicsRestartTimer = setTimeout(() => {
      updatePhysics();
    }, 100);
  }

  /************************************************************************
   * RENDERING HELPERS
   ************************************************************************/
  function clearCanvas() {
    ctx.fillStyle = formattingSettings.backgroundColor;
    ctx.fillRect(0, 0, canvas.width/(devicePixelRatio), canvas.height/(devicePixelRatio));
  }

  function applyTransform() {
    const centerX = (canvas.width/(devicePixelRatio)) / 2;
    const centerY = (canvas.height/(devicePixelRatio)) / 2;
    ctx.translate(centerX + panX, centerY + panY);
    ctx.scale(zoomLevel, zoomLevel);
    ctx.translate(-centerX, -centerY);
  }

  function roundRectPath(x, y, w, h, r) {
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
  }

  function drawChevronLabel(x1, y1, x2, y2, text, lineColor) {
    if (!text || text.trim() === '') return;
    
    // Calculate midpoint
    const midX = (x1 + x2) / 2;
    const midY = (y1 + y2) / 2;
    
    // Calculate direction vector
    const dx = x2 - x1;
    const dy = y2 - y1;
    const length = Math.sqrt(dx * dx + dy * dy);
    
    if (length === 0) return;
    
    // Normalize direction
    const ux = dx / length;
    const uy = dy / length;
    
    // Perpendicular vector
    const px = -uy;
    const py = ux;
    
    // Text measurements
    ctx.save();
    const fontSize = Math.max(11, 11 / zoomLevel);
    ctx.font = `${fontSize}px Rubik, Arial, sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const metrics = ctx.measureText(text);
    const textWidth = metrics.width;
    
    // Chevron dimensions
    const padding = 6 / zoomLevel;
    const chevronWidth = textWidth + padding * 2;
    const chevronHeight = fontSize + padding * 2;
    const chevronPointSize = chevronHeight * 0.4;
    
    // Calculate chevron points (pointing in direction of arrow)
    const halfHeight = chevronHeight / 2;
    
    // Left side
    const leftBaseX = midX - ux * chevronWidth / 2;
    const leftBaseY = midY - uy * chevronWidth / 2;
    const leftTopX = leftBaseX + px * halfHeight;
    const leftTopY = leftBaseY + py * halfHeight;
    const leftBottomX = leftBaseX - px * halfHeight;
    const leftBottomY = leftBaseY - py * halfHeight;
    
    // Right side (with point)
    const rightBaseX = midX + ux * chevronWidth / 2;
    const rightBaseY = midY + uy * chevronWidth / 2;
    const rightTopX = rightBaseX + px * halfHeight;
    const rightTopY = rightBaseY + py * halfHeight;
    const rightBottomX = rightBaseX - px * halfHeight;
    const rightBottomY = rightBaseY - py * halfHeight;
    const rightPointX = rightBaseX + ux * chevronPointSize;
    const rightPointY = rightBaseY + uy * chevronPointSize;
    
    // Draw chevron shape
    ctx.fillStyle = lineColor;
    ctx.beginPath();
    ctx.moveTo(leftTopX, leftTopY);
    ctx.lineTo(rightTopX, rightTopY);
    ctx.lineTo(rightPointX, rightPointY);
    ctx.lineTo(rightBottomX, rightBottomY);
    ctx.lineTo(leftBottomX, leftBottomY);
    ctx.closePath();
    ctx.fill();
    
    // Draw text with rotation
    ctx.save();
    // Calculate angle of the line
    let angle = Math.atan2(dy, dx);
    
    // Keep text readable (flip if upside down)
    if (angle > Math.PI / 2 || angle < -Math.PI / 2) {
      angle += Math.PI;
    }
    
    // Translate to midpoint, rotate, then draw text at origin
    ctx.translate(midX, midY);
    ctx.rotate(angle);
    ctx.fillStyle = '#FFFFFF';
    ctx.fillText(text, 0, 0);
    ctx.restore();
    
    ctx.restore();
  }

  function drawLink(l, opacity) {
    ctx.save();
    ctx.globalAlpha = opacity;
    
    // Get formatting for this link (conditional or default)
    const format = getLinkFormat(l);
    
    // Check if either end of the link is hovered
    const isHovered = hoveredNode && (l.source === hoveredNode || l.target === hoveredNode);
    
    // Check if either end is selected
    const isSelected = selectedNode && (l.source === selectedNode || l.target === selectedNode);
    
    // Check if either end is highlighted in current view (Story Mode)
    let isHighlighted = false;
    if (isStoryMode && sortedViewIds.length > 0) {
      const currentViewId = sortedViewIds[currentViewIndex];
      const sourceHighlights = entityHighlightsMap.get(l.source.id);
      const targetHighlights = entityHighlightsMap.get(l.target.id);
      isHighlighted = (sourceHighlights && sourceHighlights.has(currentViewId)) || 
                      (targetHighlights && targetHighlights.has(currentViewId));
    }
    
    // Use hover colors/thickness if link is connected to hovered node
    // Only use conditional format if lineEnabled is true
    const lineColor = isHovered ? formattingSettings.lineHoverColor : (format?.lineEnabled && format?.lineColor ? format.lineColor : formattingSettings.lineColor);
    const baseLineThickness = isHovered ? formattingSettings.lineHoverThickness : (format?.lineEnabled && format?.lineThickness ? format.lineThickness : formattingSettings.lineThickness);
    
    // Scale line thickness with the current scale factor
    const lineThickness = baseLineThickness * currentScaleFactor;
    
    ctx.beginPath();
    ctx.moveTo(l.source.x, l.source.y);
    ctx.lineTo(l.target.x, l.target.y);
    ctx.lineWidth = lineThickness / zoomLevel;
    ctx.strokeStyle = lineColor;
    ctx.stroke();
    
    // Draw arrow head and label ONLY if link is selected, hovered, or highlighted
    if (isSelected || isHovered || isHighlighted) {
      // Draw chevron label with Note text if available
      if (l.note) {
        // Set chevron to 100% opacity (same as line, not affected by link opacity)
        ctx.globalAlpha = 1.0;
        drawChevronLabel(l.source.x, l.source.y, l.target.x, l.target.y, l.note, lineColor);
      }
    }
    
    ctx.restore();
  }

  function drawNode(n, opacity, showImage=true) {
    ctx.save();
    const x = n.x, y = n.y;
    
    // Get formatting for this node (conditional or default)
    const format = getNodeFormat(n);
    const isHovered = hoveredNode && n === hoveredNode;
    const isSelected = selectedNode && n === selectedNode;
    
    // Check if this node is connected to the hovered node
    const isConnectedToHovered = hoveredNode && hoveredNode !== n && 
                                  adjacency.get(hoveredNode.id)?.has(n.id);
    
    // Check if this node should be highlighted in the current view (Story Mode)
    let isHighlightedInView = false;
    if (isStoryMode && sortedViewIds.length > 0) {
      const currentViewId = sortedViewIds[currentViewIndex];
      const highlightViews = entityHighlightsMap.get(n.id);
      isHighlightedInView = highlightViews && highlightViews.has(currentViewId);
    }
    
    // Use hover colors/thickness if node is hovered OR selected OR highlighted in current view
    // Only use conditional format if the respective section is enabled
    const nodeColor = isHovered ? formattingSettings.nodeHoverColor : (format?.nodeEnabled && format?.nodeColor ? format.nodeColor : formattingSettings.nodeColor);
    const outlineColor = (isHovered || isSelected || isConnectedToHovered || isHighlightedInView) ? formattingSettings.outlineHoverColor : (format?.outlineEnabled && format?.outlineColor ? format.outlineColor : formattingSettings.outlineColor);
    const baseOutlineThickness = (isHovered || isSelected || isConnectedToHovered || isHighlightedInView) ? formattingSettings.outlineHoverThickness : (format?.outlineEnabled && format?.outlineThickness ? format.outlineThickness : formattingSettings.outlineThickness);
    
    // Scale outline thickness with the current scale factor
    const outlineThickness = baseOutlineThickness * currentScaleFactor;
    
    // Node radius already includes scale factor from scaleNodesToFit
    const r = n.r;

    if (showImage && n.imageBitmap) {
      ctx.save();
      ctx.globalAlpha = opacity;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI*2);
      ctx.clip();
      const img = n.imageBitmap;
      const iw = img.width || img.naturalWidth || 1;
      const ih = img.height || img.naturalHeight || 1;
      const target = r * 2;
      const scale = Math.max(target / iw, target / ih);
      const dw = iw * scale;
      const dh = ih * scale;
      const dx = x - dw / 2;
      const dy = y - dh / 2;
      try {
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(img, dx, dy, dw, dh);
      } catch (e) {
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI*2);
        ctx.fillStyle = nodeColor;
        ctx.fill();
      }
      ctx.restore();
    } else {
      ctx.save();
      ctx.globalAlpha = opacity;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI*2);
      ctx.fillStyle = nodeColor;
      ctx.fill();
      ctx.restore();
    }

    // Draw outline with glow if this is the selected node
    ctx.save();
    ctx.globalAlpha = opacity;
    
    // Add pulsing glow for selected node
    if (selectedNode && n === selectedNode) {
      const pulsePhase = Math.sin(animationTime * 0.002) * 0.5 + 0.5; // Oscillates between 0 and 1
      const glowSize = (5 + pulsePhase * 10) * currentScaleFactor; // Scale glow with nodes
      const glowAlpha = 0.5 + pulsePhase * 0.5; // Varies between 0.5 and 1
      
      // Convert hover outline color to rgba for glow effect
      const hoverColor = formattingSettings.outlineHoverColor;
      const rr = parseInt(hoverColor.slice(1, 3), 16);
      const gg = parseInt(hoverColor.slice(3, 5), 16);
      const bb = parseInt(hoverColor.slice(5, 7), 16);
      
      ctx.shadowColor = `rgba(${rr}, ${gg}, ${bb}, ${glowAlpha})`;
      ctx.shadowBlur = glowSize;
    }
    
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI*2);
    ctx.lineWidth = outlineThickness / zoomLevel;
    ctx.strokeStyle = outlineColor;
    ctx.stroke();
    ctx.restore();

    ctx.restore();
  }

  function drawLabel(n) {
    const text = n.name || '';
    if (!text) return;
    ctx.save();
    ctx.font = `${CONFIG.labelFontSize / zoomLevel}px Rubik, Arial, sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const metrics = ctx.measureText(text);
    const textW = metrics.width;
    const pad = CONFIG.labelBoxPadding / zoomLevel;
    const boxW = textW + pad * 2;
    const boxH = (CONFIG.labelFontSize + 6) / zoomLevel;
    const x = n.x - boxW / 2;
    const y = n.y + n.r + CONFIG.labelOffsetY / zoomLevel;

    ctx.save();
    ctx.globalAlpha = CONFIG.labelBoxOpacity;
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    roundRectPath(x, y, boxW, boxH, 6 / zoomLevel);
    ctx.fill();
    ctx.restore();

    ctx.fillStyle = '#111827';
    ctx.fillText(text, n.x, y + boxH / 2);
    ctx.restore();
  }

  function shouldHighlightNode(node) {
    // In story mode, nodes not in current view should be unhighlighted (low opacity)
    if (isStoryMode && sortedViewIds.length > 0) {
      const currentViewId = sortedViewIds[currentViewIndex];
      const currentViewEntities = new Set(viewEntitiesCache.get(currentViewId) || []);
      if (!currentViewEntities.has(node.id)) {
        return false; // Not in current view, show with low opacity
      }
    }
    
    if (!selectedNode) return true;
    const activeSet = new Set([selectedNode.id, ...(adjacency.get(selectedNode.id) || [])]);
    return activeSet.has(node.id);
  }

  /************************************************************************
   * RENDER
   ************************************************************************/
  function render() {
    animationTime = Date.now();
    clearCanvas();
    if (!nodes || nodes.length === 0) return;

    ctx.save();
    applyTransform();

    // Filter nodes based on story mode
    let visibleNodes = nodes.filter(n => n.show);
    const highlightedNodes = [];
    const unhighlightedNodes = [];
    
    visibleNodes.forEach(node => {
      if (shouldHighlightNode(node)) {
        highlightedNodes.push(node);
      } else {
        unhighlightedNodes.push(node);
      }
    });

    // Draw unhighlighted nodes first (dimmed)
    unhighlightedNodes.forEach(n => drawNode(n, CONFIG.unconnectedOpacity, CONFIG.showImages));

    const highlightedSet = new Set(highlightedNodes.map(n => n.id));
    let visibleLinks = links.filter(l => l.source.show && l.target.show);
    
    // In story mode, only show links where BOTH nodes are in current view
    if (isStoryMode && sortedViewIds.length > 0) {
      const currentViewId = sortedViewIds[currentViewIndex];
      const currentViewEntities = new Set(viewEntitiesCache.get(currentViewId) || []);
      visibleLinks = visibleLinks.filter(l => currentViewEntities.has(l.source.id) && currentViewEntities.has(l.target.id));
    }
    
    // Draw links - ONLY draw links between highlighted nodes when there's a selection
    // Sort links by priority: selected & hovered > selected & not hovered > unselected & hovered > unselected & not hovered
    const sortedLinks = visibleLinks.slice().sort((a, b) => {
      const aIsSelected = selectedNode && (a.source === selectedNode || a.target === selectedNode);
      const bIsSelected = selectedNode && (b.source === selectedNode || b.target === selectedNode);
      const aIsHovered = hoveredNode && (a.source === hoveredNode || a.target === hoveredNode);
      const bIsHovered = hoveredNode && (b.source === hoveredNode || b.target === hoveredNode);
      
      // Calculate priority (higher number = drawn later = appears on top)
      const aPriority = (aIsSelected ? 2 : 0) + (aIsHovered ? 1 : 0);
      const bPriority = (bIsSelected ? 2 : 0) + (bIsHovered ? 1 : 0);
      
      return aPriority - bPriority; // Draw lower priority first
    });
    
    if (selectedNode) {
      sortedLinks.forEach(l => {
        if (highlightedSet.has(l.source.id) && highlightedSet.has(l.target.id)) {
          drawLink(l, CONFIG.linkOpacitySelected);
        }
      });
    } else {
      sortedLinks.forEach(l => {
        drawLink(l, CONFIG.linkOpacityNoSelection);
      });
    }

    // Draw highlighted nodes on top
    highlightedNodes.forEach(n => drawNode(n, CONFIG.pointOpacity, CONFIG.showImages));

    // Draw labels for selected node and its connections
    if (selectedNode) {
      highlightedNodes.forEach(n => {
        if (adjacency.get(selectedNode.id).has(n.id) || n === selectedNode) {
          drawLabel(n);
        }
      });
    }

    // Draw label for hovered node (if not already labeled)
    if (hoveredNode && hoveredNode !== selectedNode && hoveredNode.show) {
      drawLabel(hoveredNode);
    }

    ctx.restore();
    
    // Schedule next animation frame only if a node is selected (for glow animation)
    if (selectedNode && !animationScheduled) {
      animationScheduled = true;
      setTimeout(() => {
        animationScheduled = false;
        requestAnimationFrame(render);
      }, 50); // ~20 FPS for smooth animation with less CPU usage
    }
  }

  /************************************************************************
   * INTERACTION HELPERS
   ************************************************************************/
  function getCanvasPos(evt) {
    const rect = canvas.getBoundingClientRect();
    const x = (evt.clientX - rect.left) * (canvas.width / (devicePixelRatio)) / rect.width;
    const y = (evt.clientY - rect.top) * (canvas.height / (devicePixelRatio)) / rect.height;
    
    const centerX = (canvas.width/(devicePixelRatio)) / 2;
    const centerY = (canvas.height/(devicePixelRatio)) / 2;
    
    const transformedX = (x - centerX - panX) / zoomLevel + centerX;
    const transformedY = (y - centerY - panY) / zoomLevel + centerY;
    
    return { x: transformedX, y: transformedY };
  }

  function findNodeAtPos(x, y) {
    if (!nodes || nodes.length === 0) return null;
    let visibleNodes = nodes.filter(n => n.show);
    
    if (selectedNode) {
      const activeSet = new Set([selectedNode.id, ...(adjacency.get(selectedNode.id) || [])]);
      const activeNodes = visibleNodes.filter(n => activeSet.has(n.id));
      for (let i = activeNodes.length - 1; i >= 0; i--) {
        const n = activeNodes[i];
        if (Math.hypot(n.x - x, n.y - y) <= n.r) return n;
      }
      const otherNodes = visibleNodes.filter(n => !activeSet.has(n.id));
      for (let i = otherNodes.length - 1; i >= 0; i--) {
        const n = otherNodes[i];
        if (Math.hypot(n.x - x, n.y - y) <= n.r) return n;
      }
    } else {
      for (let i = visibleNodes.length - 1; i >= 0; i--) {
        const n = visibleNodes[i];
        if (Math.hypot(n.x - x, n.y - y) <= n.r) return n;
      }
    }
    return null;
  }

  function snapToGrid(x, y) {
    return {
      x: Math.round(x / CONFIG.gridSize) * CONFIG.gridSize,
      y: Math.round(y / CONFIG.gridSize) * CONFIG.gridSize
    };
  }

  function updateCanvasCursor() {
    if (isDraggingNode) {
      canvas.style.cursor = 'grabbing';
    } else if (isDragging) {
      canvas.style.cursor = 'grabbing';
    } else if (zoomLevel > 1.0) {
      canvas.style.cursor = 'grab';
    } else {
      canvas.style.cursor = 'default';
    }
  }

  /************************************************************************
   * CANVAS EVENT LISTENERS
   ************************************************************************/
  canvas.addEventListener('mousedown', (evt) => {
    if (evt.button !== 0) return;
    
    didDrag = false;
    const pos = getCanvasPos(evt);
    const n = findNodeAtPos(pos.x, pos.y);
    
    if (n) {
      mouseDownNode = n;
      mouseDownTime = Date.now();
      
      dragDelayTimer = setTimeout(() => {
        if (mouseDownNode === n) {
          // Stop physics during drag
          if (simulation) simulation.stop();
          
          // Deselect any currently selected node immediately
          selectedNode = null;
          clearInfoPanel();
          
          isDraggingNode = true;
          draggedNode = n;
          
          // Save unfixed position before dragging
          if (!n.isFixed) {
            n.unfixedX = n.x;
            n.unfixedY = n.y;
          }
          
          updateCanvasCursor();
          render();
        }
      }, CONFIG.dragDelayMs);
      
      evt.preventDefault();
    } else if (zoomLevel > 1.0) {
      // Panning canvas
      isDragging = true;
      dragStartX = evt.clientX;
      dragStartY = evt.clientY;
      dragStartPanX = panX;
      dragStartPanY = panY;
      updateCanvasCursor();
      evt.preventDefault();
    }
  });

  canvas.addEventListener('mousemove', (evt) => {
    if (isDraggingNode && draggedNode) {
      didDrag = true;
      const pos = getCanvasPos(evt);
      const snapped = snapToGrid(pos.x, pos.y);
      draggedNode.x = snapped.x;
      draggedNode.y = snapped.y;
      render();
      evt.preventDefault();
    } else if (isDragging && zoomLevel > 1.0) {
      didDrag = true;
      const deltaX = evt.clientX - dragStartX;
      const deltaY = evt.clientY - dragStartY;
      panX = dragStartPanX + deltaX / zoomLevel;
      panY = dragStartPanY + deltaY / zoomLevel;
      render();
      evt.preventDefault();
    } else {
      // Hover effect
      const pos = getCanvasPos(evt);
      const n = findNodeAtPos(pos.x, pos.y);
      if (n !== hoveredNode) {
        hoveredNode = n;
        render();
      }
    }
  });

  canvas.addEventListener('mouseup', (evt) => {
    if (dragDelayTimer) {
      clearTimeout(dragDelayTimer);
      dragDelayTimer = null;
    }
    
    if (isDraggingNode && draggedNode) {
      const snapped = snapToGrid(draggedNode.x, draggedNode.y);
      draggedNode.x = snapped.x;
      draggedNode.y = snapped.y;
      draggedNode.isFixed = true;
      draggedNode.fx = snapped.x;
      draggedNode.fy = snapped.y;
      
      schedulePhysicsRestart();
      
      isDraggingNode = false;
      draggedNode = null;
      mouseDownNode = null;
      updateCanvasCursor();
      render();
      evt.preventDefault();
      return;
    }
    
    if (isDragging) {
      isDragging = false;
      updateCanvasCursor();
      
      // Only treat as click if we didn't drag
      if (!didDrag) {
        const pos = getCanvasPos(evt);
        const n = findNodeAtPos(pos.x, pos.y);
        if (n) {
          selectedNode = n;
          if (isStoryMode) {
            showEntityModal(n);
          } else {
            populateInfoPanel(n);
          }
          render();
        } else {
          selectedNode = null;
          if (isStoryMode) {
            hideEntityModal();
          } else {
            clearInfoPanel();
          }
          render();
        }
      }
      evt.preventDefault();
      return;
    }
    
    if (mouseDownNode) {
      const timeSinceDown = Date.now() - mouseDownTime;
      if (timeSinceDown < CONFIG.dragDelayMs && !didDrag) {
        const pos = getCanvasPos(evt);
        const n = findNodeAtPos(pos.x, pos.y);
        if (n && n === mouseDownNode) {
          selectedNode = n;
          if (isStoryMode) {
            showEntityModal(n);
          } else {
            populateInfoPanel(n);
          }
          render();
        }
      }
      mouseDownNode = null;
    }
  });

  canvas.addEventListener('click', (evt) => {
    if (didDrag) {
      didDrag = false;
      evt.preventDefault();
      return;
    }
    if (isDragging || isDraggingNode) return;
    const pos = getCanvasPos(evt);
    const n = findNodeAtPos(pos.x, pos.y);
    if (n) {
      selectedNode = n;
      if (isStoryMode) {
        showEntityModal(n);
      } else {
        populateInfoPanel(n);
      }
      render();
    } else {
      selectedNode = null;
      if (isStoryMode) {
        hideEntityModal();
      } else {
        clearInfoPanel();
      }
      render();
    }
  });

  canvas.addEventListener('mouseleave', (evt) => {
    if (dragDelayTimer) {
      clearTimeout(dragDelayTimer);
      dragDelayTimer = null;
    }
    
    isDragging = false;
    didDrag = false;
    if (isDraggingNode) {
      schedulePhysicsRestart();
    }
    isDraggingNode = false;
    draggedNode = null;
    mouseDownNode = null;
    updateCanvasCursor();
    if (hoveredNode) {
      hoveredNode = null;
      render();
    }
  });

  canvas.addEventListener('wheel', (evt) => {
    evt.preventDefault();
    if (evt.deltaY < 0) {
      zoomIn();
    } else {
      zoomOut();
    }
  });

  /************************************************************************
   * ZOOM CONTROLS
   ************************************************************************/
  function zoomIn() {
    zoomLevel = Math.min(CONFIG.zoomMax, zoomLevel + CONFIG.zoomStep);
    updateCanvasCursor();
    render();
  }
  
  function zoomOut() {
    zoomLevel = Math.max(CONFIG.zoomMin, zoomLevel - CONFIG.zoomStep);
    updateCanvasCursor();
    render();
  }
  
  function resetZoom() {
    zoomLevel = 1.0;
    panX = 0;
    panY = 0;
    updateCanvasCursor();
    render();
  }

  zoomInBtn.addEventListener('click', zoomIn);
  zoomOutBtn.addEventListener('click', zoomOut);
  zoomResetBtn.addEventListener('click', resetZoom);


  /************************************************************************
   * INFO PANEL
   ************************************************************************/
  function normalizeUrl(u) {
    if (!u) return null;
    const s = String(u).trim();
    if (s === '') return null;
    if (/^[a-zA-Z][a-zA-Z0-9+\-.]*:\/\//.test(s)) return s;
    return 'https://' + s.replace(/^[\/]+/, '');
  }

  function populateInfoPanel(d) {
    const desc = (d.raw && (d.raw['Description'] || '')) || '';
    const category = (d.raw && (d.raw['Category'] || '')) || '';

    const rawLink = (d.raw && (d.raw['Link'] || d.raw['Link '])) || '';
    const safe = normalizeUrl(rawLink);
    const rawMoreInfo = (d.raw && (d.raw['DeSmog Profile'] || d.raw['DeSmog Profile'])) || '';
    const safeMoreInfo = normalizeUrl(rawMoreInfo);

    let links = [];
    if (safe) links.push(`<a href="${safe}" target="_blank" rel="noopener">More Info</a>`);
    if (safeMoreInfo) links.push(`<a href="${safeMoreInfo}" target="_blank" rel="noopener">DeSmog Profile</a>`);
    const linksHTML = links.length > 0 ? links.join(' | ') : '';

    nodeTitleEl.html(`
      <div style="display:flex; align-items:center; gap:8px; font-size:24px; font-weight:700;">
        <span>${d.name}</span>
        ${d.image ? `<img src="${d.image}" style="width:40px; height:40px; object-fit:cover; border-radius:50%;">` : ''}
      </div>
      ${category ? `<div style="font-size: 16px; font-weight: bold; margin-top: 6px;">${category.replace(/\n/g, '<br>')}</div>` : ''}
      <br>
      ${desc ? `<div style="font-size: 14px; font-weight: normal; max-height: 350px; overflow-y: auto; margin-top: 6px;">${desc.replace(/\n/g, '<br>')}</div>` : ''}
      ${linksHTML ? `<div style="margin-top: 8px;">${linksHTML}</div>` : ''}
      <div style="font-size: 14px; font-weight: bold; margin-top: 6px;">
        <br>
        <br>Connections: 
      </div>
    `);

    nodeLinkEl.html('');

    const conns = Array.from(adjacency.get(d.id) || []).slice();
    conns.sort((a,b) => a.localeCompare(b, undefined, {sensitivity:'base'}));
    connectionsBox.innerHTML = '';
    if (conns.length === 0) {
      connectionsBox.innerHTML = '<div class="muted">No connections</div>';
      return;
    }
    const frag = document.createDocumentFragment();
    const nodeSourceMap = connectionSources.get(d.id);
    const nodeTextsMap = connectionTexts.get(d.id);
    conns.forEach(name => {
      const item = document.createElement('div');
      item.className = 'conn-item';
      item.style.display = 'flex';
      item.style.alignItems = 'center';
      item.style.justifyContent = 'space-between';
      item.style.gap = '8px';
      
      const nameSpan = document.createElement('span');
      // Display the text description if available, otherwise fall back to node name
      const textDesc = nodeTextsMap ? nodeTextsMap.get(name) : null;
      nameSpan.textContent = textDesc || name;
      nameSpan.style.flex = '1';
      nameSpan.style.cursor = 'pointer';
      nameSpan.addEventListener('click', () => {
        const targetNode = nodeById.get(name);
        if (targetNode) {
          selectedNode = targetNode;
          populateInfoPanel(targetNode);
          render();
          connectionsBox.scrollTop = 0;
        }
      });
      item.appendChild(nameSpan);
      
      const sourceUrl = nodeSourceMap ? nodeSourceMap.get(name) : null;
      if (sourceUrl) {
        const sourceIcon = document.createElement('a');
        sourceIcon.href = normalizeUrl(sourceUrl) || '#';
        sourceIcon.target = '_blank';
        sourceIcon.rel = 'noopener';
        sourceIcon.innerHTML = '🔗';
        sourceIcon.style.fontSize = '16px';
        sourceIcon.style.textDecoration = 'none';
        sourceIcon.style.cursor = 'pointer';
        sourceIcon.style.flexShrink = '0';
        sourceIcon.title = 'View source';
        sourceIcon.addEventListener('click', (e) => {
          e.stopPropagation();
        });
        item.appendChild(sourceIcon);
      }
      
      frag.appendChild(item);
    });
    connectionsBox.appendChild(frag);
  }

  function clearInfoPanel() {
    nodeTitleEl.html('Select a node or start story');
    nodeMetaEl.text('');
    nodeLinkEl.html('');
    connectionsBox.innerHTML = '';
  }

  /************************************************************************
   * SEARCH
   ************************************************************************/
  searchInput.addEventListener('input', onSearchInput);
  searchBtn.addEventListener('click', () => performSearch(searchInput.value.trim()));
  searchInput.addEventListener('keydown', (ev) => { 
    if (ev.key === 'Enter') { 
      performSearch(searchInput.value.trim()); 
      ev.preventDefault(); 
    } 
  });

  clearBtn.addEventListener('click', () => { 
    selectedNode = null;
    
    if (isStoryMode) {
      hideEntityModal();
    } else {
      clearInfoPanel();
    }
    
    render(); 
    searchInput.value = ''; 
    suggestionsEl.style('display', 'none').html(''); 
    msgEl.text('');
  });

  function onSearchInput() {
    const q = searchInput.value.trim();
    suggestionsEl.style('display', 'none').html('');
    msgEl.text('');
    if (!q || q.length < 3) return;
    const term = q.toLowerCase();
    const matches = [];
    
    // In story mode, only search within current view's entities
    let searchSpace = nameIndex;
    if (isStoryMode && sortedViewIds.length > 0) {
      const currentViewId = sortedViewIds[currentViewIndex];
      const currentViewEntities = viewEntitiesCache.get(currentViewId) || [];
      searchSpace = currentViewEntities;
    }
    
    for (const name of searchSpace) {
      if (name && name.toLowerCase().includes(term)) matches.push(name);
      if (matches.length >= CONFIG.maxSuggestions) break;
    }
    if (matches.length === 0) {
      suggestionsEl.style('display','block').html('<div class="muted">No suggestions</div>');
      return;
    }
    suggestionsEl.style('display','block').html('');
    matches.forEach(m => {
      suggestionsEl.append('div').attr('class','suggestion').text(m).on('click', () => {
        searchInput.value = m;
        suggestionsEl.style('display','none').html('');
        performSearch(m);
      });
    });
  }

  function performSearch(q) {
    if (!q) return;
    
    // In story mode, only search within current view's entities
    let searchNodes = nodes;
    if (isStoryMode && sortedViewIds.length > 0) {
      const currentViewId = sortedViewIds[currentViewIndex];
      const currentViewEntities = new Set(viewEntitiesCache.get(currentViewId) || []);
      searchNodes = nodes.filter(n => currentViewEntities.has(n.id));
    }
    
    const exact = searchNodes.find(n => n.name && n.name.toLowerCase() === q.toLowerCase());
    if (exact) {
      selectedNode = exact;
      
      if (isStoryMode) {
        showEntityModal(exact);
      } else {
        populateInfoPanel(exact);
      }
      
      render(); 
      msgEl.text(''); 
      return;
    }
    const matches = searchNodes.filter(n => n.name && n.name.toLowerCase().includes(q.toLowerCase()));
    if (matches.length === 1) {
      selectedNode = matches[0];
      
      if (isStoryMode) {
        showEntityModal(matches[0]);
      } else {
        populateInfoPanel(matches[0]);
      }
      
      render(); 
      msgEl.text(''); 
      return;
    } else if (matches.length > 1) {
      suggestionsEl.style('display','block').html('');
      matches.slice(0, CONFIG.maxSuggestions).forEach(m => {
        suggestionsEl.append('div').attr('class','suggestion').text(m.name).on('click', () => {
          searchInput.value = m.name;
          suggestionsEl.style('display','none').html('');
          selectedNode = m;
          
          if (isStoryMode) {
            showEntityModal(m);
          } else {
            populateInfoPanel(m);
          }
          
          render();
        });
      });
      msgEl.text('Multiple matches — click a suggestion.'); 
      return;
    } else {
      msgEl.text('Search term not found. Please try again.');
    }
  }

  /************************************************************************
   * STORY MODE EVENT LISTENERS
   ************************************************************************/
  storyBtn.addEventListener('click', enterStoryMode);
  storyExitBtn.addEventListener('click', exitStoryMode);
  storyPrevBtn.addEventListener('click', () => navigateView('prev'));
  storyNextBtn.addEventListener('click', () => navigateView('next'));
  entityModalClose.addEventListener('click', hideEntityModal);

  /************************************************************************
   * INITIALIZE
   ************************************************************************/
  render();
  autoLoadData();
  </script>
</body>
</html>